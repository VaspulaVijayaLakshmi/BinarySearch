You have one  chocolate bar that consists of some chunks. Each chunk has its own sweetness given by the array sweetness.

You want to share the  chocolate with your K friends so you start cutting the chocolate bar into K+1 pieces using K cuts,
each piece consists of some consecutive chunks.

Being generous, you will eat the piece with the minimum total sweetness and give the other pieces to your friends.

Find the maximum total sweetness of the piece you can get by cutting the chocolate bar optimally.


Example 1:
Input: sweetness = [1,2,3,4,5,6,7,8,9], K = 5
Output: 6
Explanation: You can divide the chocolate to [1,2,3], [4,5], [6], [7], [8], [9]


Example 2:
Input: sweetness = [5,6,7,8,9,1,2,3,4], K = 8
Output: 1
Explanation: There is only one way to cut the bar into 9 pieces.


Example 3:
Input: sweetness = [1,2,2,1,2,2,1,2,2], K = 2
Output: 5
Explanation: You can divide the chocolate to [1,2,2], [1,2,2], [1,2,2]

_______

Already admitted - maximize total sweetness you get by picking up the mimimum total sweetness bar
so the max and min sweetness u can get : 



class Solution {
public:

   bool canDivide(vector<int>& sweetness,int minSweetness, int pieces){

         int currSweetness=0,piecesFormed=0;
         for(int i=0;i<sweetness.begin();i++){

             currSweetness +=sweetness[i];
             if(currSweetness>=minSweetness){
                  piecesFormed+=1;
                  currSweetness=0;
             }
         }

        return piecesFormed>=pieces;


   }

    int maximizeSweetness(vector<int>& sweetness, int k) {
       
        int l = *min_element(sweetness.begin(), sweetness.end());
        int r = accumulate(sweetness.begin(), sweetness.end(), 0) / (k+1);

        int ans = 0;

        while (l <= r) {
            int mid = l + (r - l) / 2;

            if (canDivide(sweetness, mid, k+1)) {
                ans = mid;
                l = mid + 1; // try for higher minimum
            } else {
                r = mid - 1;
            }
        }
        return ans;
    }
}


__________________________




Since ninja is generous he'll take the min sweetness.

so what we need to do is, we need to the slices such tht even if he takes min swetness one
he will atleast maximise

minimum sweetness
maximize the total sweetness
Consecutive cuts





-> this is maximize the minimum swetness

9 chcolates , 3 friends
5 6 7 8 9 10 11 12 13

I have this sweetness array

4 pieces - 3 cuts 



so cut into 3 pieces

5 6 7 8 9 10 11 12 13

[5, 6, 7], [8, 9], [10, 11], [12, 13] - [18,17,21,25] 
                                        [so i need take diff]
                                        so that thats the max sweetness i can get

                                        in this i will need to take 17 - so diff is min



[5, 6], [7, 8, 9], [10, 11,12], [13] - [11,24,31,13] - min swetness -13

.....


like this so many division
SO i can do recursion + backtracking

but Optimizations I can work on BS + Greedy


Min amd max

MIn - min shcolate swettness - we will give the min sweetness one ti the ninja
Max - max would be - sum of sweetness/k , that means all get the same sweetness











_________________________

This is a maximize the minimum problem → Binary Search on answer.

Range of sweetness you can eat:

Minimum possible = min(sweetness) (at least one piece will have this much).
Maximum possible = sum(sweetness) / (k+1) (if perfectly balanced).


Binary search on minSweetness (the sweetness you can guarantee).

Greedily check:

-> Traverse sweetness.
-> Keep adding until sum ≥ minSweetness.
-> Cut → reset sum.
-> Count how many pieces you get.

If we can make ≥ (k+1) pieces, it means we can push minSweetness higher.
Otherwise, lower it.









