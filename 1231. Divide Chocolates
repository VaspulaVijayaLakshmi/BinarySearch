You have one  chocolate bar that consists of some chunks. Each chunk has its own sweetness given by the array sweetness.

You want to share the  chocolate with your K friends so you start cutting the chocolate bar into K+1 pieces using K cuts,
each piece consists of some consecutive chunks.

Being generous, you will eat the piece with the minimum total sweetness and give the other pieces to your friends.

Find the maximum total sweetness of the piece you can get by cutting the chocolate bar optimally.


Example 1:
Input: sweetness = [1,2,3,4,5,6,7,8,9], K = 5
Output: 6
Explanation: You can divide the chocolate to [1,2,3], [4,5], [6], [7], [8], [9]


Example 2:
Input: sweetness = [5,6,7,8,9,1,2,3,4], K = 8
Output: 1
Explanation: There is only one way to cut the bar into 9 pieces.


Example 3:
Input: sweetness = [1,2,2,1,2,2,1,2,2], K = 2
Output: 5
Explanation: You can divide the chocolate to [1,2,2], [1,2,2], [1,2,2]

_______

Already admitted - maximize total sweetness you get by picking up the mimimum total sweetness bar
so the max and min sweetness u can get : 



class Solution {
public:

   bool canDivide(vector<int>& sweetness,int minSweetness, int pieces){

         int currSweetness=0,piecesFormed=0;
         for(int i=0;i<sweetness.begin();i++){

             currSweetness +=sweetness[i];
             if(currSweetness>=minSweetness){
                  piecesFormed+=1;
                  currSweetness=0;
             }
         }

        return piecesFormed>=pieces;


   }

    int maximizeSweetness(vector<int>& sweetness, int k) {
       
        int l = *min_element(sweetness.begin(), sweetness.end());
        int r = accumulate(sweetness.begin(), sweetness.end(), 0) / (k+1);

        int ans = 0;

        while (l <= r) {
            int mid = l + (r - l) / 2;

            if (canDivide(sweetness, mid, k+1)) {
                ans = mid;
                l = mid + 1; // try for higher minimum
            } else {
                r = mid - 1;
            }
        }
        return ans;
    }
}


__________________________


This is a maximize the minimum problem → Binary Search on answer.

Range of sweetness you can eat:

Minimum possible = min(sweetness) (at least one piece will have this much).
Maximum possible = sum(sweetness) / (k+1) (if perfectly balanced).


Binary search on minSweetness (the sweetness you can guarantee).

Greedily check:

-> Traverse sweetness.
-> Keep adding until sum ≥ minSweetness.
-> Cut → reset sum.
-> Count how many pieces you get.

If we can make ≥ (k+1) pieces, it means we can push minSweetness higher.
Otherwise, lower it.









