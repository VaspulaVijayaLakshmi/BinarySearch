class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        

        //if one is bigger then swap.
        if (nums1.size() > nums2.size()) {
            return findMedianSortedArrays(nums2, nums1);
        }
        
        int len1=nums1.size();
        int len2 = nums2.size();

        int left=0,right=len1;

        while(left<=right){

            int part1 = (left+right)/2;
            int part2 = (len1+len2+1)/2 - part1;

            int maxLeft1 = (part1 == 0) ? INT_MIN : nums1[part1 - 1];
            int minRight1 = (part1 == len1) ? INT_MAX : nums1[part1];
            int maxLeft2 = (part2 == 0) ? INT_MIN : nums2[part2 - 1];
            int minRight2 = (part2 == len2) ? INT_MAX : nums2[part2];

        if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1) {

            //if even -> return  avg of 2 elements
                if ((len1 + len2) % 2 == 0) {
                    return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) / 2.0;
                } 
                
                //if odd -> return one element
                else {
                    return max(maxLeft1, maxLeft2);
                }


            } else if (maxLeft1 > minRight2) {
                right = part1 - 1;
            } else {
                left = part1 + 1;
            }

        }

        return 0.0; 
    }
};


// [1,3,5,7,9]
// [2,4,5,8]


// brute force approach would be merge the arrays then find median

// [1,2,3,4,5,5,7,8,9]

// O(M+N)

// copy all the elemnts to new array and then sort.
// merge sort -> O(NlogN) 

// 2 pointer approach

// O(M+N)


// [1,3,5,7,9]
// [2,4,5,8]

// [1,2,3,4,5,5,7,8,9] -> 5 median

// m+n/2

// 3 cases :

// arr1[n] < arr2[0] -> median would be mid
// arr1[1] == arr2[0] -> then also do median and find the indx

// 3rd case cricitcal -> arr1[n]>arr2[0]

// [1,3,5,7,9]
// [2,4,5,8]


// [1,2,3,4,5,5,7,8,9] -> 4

// [1,3,5]    [7,9]
// [2,4]      [5,8]


// now we need to understand the partition
// how to partiiton 


// POINTER :
//  we can compute the median by finding the maximum of the left half or the average of the max of the left and the min of the right.


// we divide each array into left and right parts — the left parts of nums1 and nums2 form the "smaller group", and the right parts form the "larger group". We calculate the partition in such a way that the entire combined array would be sorted.



// now median will divide the elements into 2 halfs of equal proportions


// [1,2,3,4,5,6,7,8,9]

//****Left part should be smaller group and right part should be bigger.

// [5 elemnts] [4 elements] or vice versa


// now partion at different points


// [5 elemnts] [4 elements]

// for 5 elemnt in the first partion we can put points at different points in our array

// _____

// 1.

// 1 element from 1st array then 4 elements from 2nd array

// [1]          [3,5,7,9]
// [2,4,5,6] 

// ______

// 2. 2 eleemnts from 1st array then 3 elemnts from the 2nd

// [1,3]        [5,7,9]
// [2,4,5]        [6]

// ______

// 3.

// 3 elets from 1stv array

// [1,3,5]     [7,9]
// [2,4]        [5,6]

// ______

// 4. 4 elements

// [1,3,5,7]   [9]
// [2,4]       [5,6]



// so now see this is wrong when we tke 4 elements from 1st array because

// we considered 7 from 1stv array, but the [5,6] in the 2nd array 
// are less than 7, so they may come before median

// so we need to find a partiion point, where this is not violated


//           l1    r1  
// // [1,3,5,7]    [9]

//       l2        r2  
// //.   [2]       [4,5,6]


// so now it all depends on l1,l2,r1,r2 -> [7,2,9,4]

// so the max point i can take in arr[1] -> only of it less than r2

// l1 < r2

// that means in our case 7>4 -> this is wrong

// so now move the pointer

// [1,3,5]   [7,9]
// [2,4]     [5,6]

// now l1<r2 -> less than or equal to we will see later


// now also l2<r1

// like take an example where

// [1,2,5]   [7,9]
// [2,8]     [10,12]

// now we have right l1<r2
// but if we see , [2,8], 7 should not be on right side of partion it should be on left side 

// [1,2,5,7]. [9]
// [2]        [8,10,12]


// [1,2,2,5,7,8,8,10,12]
//         (5,7) -> median

//         so left side is 
//         [1,2,2,5,7] [8,8,10,12]



// __________________

// eg 2:

// nums1 = [1, 3, | 8]
// nums2 = [7 | 9, 10, 11]

// max_left1 = 3
// min_right1 = 8
// max_left2 = 7
// min_right2 = 9
// if max_left1 <= min_right2 and max_left2 <= min_right1
// = 3 <= 9 and 7 <= 8
// = true → array is correctly partitioned




// ____________________


// How to Determine Partitions
// The partition that determines left and right sides is calculated using the binary search left and right.

// eg : 
// nums1 = [1, 3, 8]
// nums2 = [7, 9, 10, 11]

// BS -> first 

// left =0 , right=len(arr1) *****

// total = len1+len2/2 -> median divides arrays at total index(elements)


// formula where to plce partion if i put parttion one at l+r/2 -> i.e half elemntets from arr1 then remaining elements in partion one should be

//  then in 2nd partion in arr2 should have remaining elements -> ((len1+len2)/2 - partition)


// partition1 = (left + right) // 2 
// partition2 = (len1 + len2 + 1) // 2 - partition1


// partition1 + partition2 = (len1 + len2 + 1) // 2
// partition2 = (len1 + len2 + 1) // 2 - partition1



// Initialization:
// len1 = 3
// len2 = 4
// left = 0
// right = 3  # len1


// First Binary Search:
// part1 = 1 → (left + right) // 2
// part2 = 3 → (len1 + len2 + 1) // 2 - partition1


// max_left1 = 1
// min_right1 = 3

// max_left2 = 10
// min_right2 = 11

// part means partition
// nums1 = [1 | 3, 8]
// nums2 = [7, 9, 10 | 11]

// Check if we have correct partitions

// if max_left1 <= min_right2 and max_left2 <= min_right1
// = 1 <= 11 and 10 <= 3 → false


// execute BS again, this means that we need to go to left in arr1
// why because max element in l2 > min element in r1

// if max_left1 > min_right2

// left = part1+1

// else
// right=part1-1



// if max_left1 > min_right2
// = 1 > 11
// = false
// Since it's false, we move:

// left = part1 + 1
// = 2

// Now let's proceed to the next binary search.

// ....
// https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/6723070/video-divide-each-array-into-two-groups-2hgjq/?envType=problem-list-v2&envId=plakya4j
